# -*- coding: utf-8 -*-
"""FIFA_21_Data_Cleaning.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OO2DlLgxknPQPoX3xIvIsGghaxJ6DukI

# DATA CLEANING ON FIFA_21 DATASET

### **Data Cleaning by: Thelma A. Nweke-Emagurehor**



---

###**Project Overview**

**Introduction:**
This project aims to clean and preprocess the FIFA player dataset, which contains detailed attributes and skills of soccer players.


**Project Background:**
The FIFA dataset contains information on various aspects of soccer players, teams, and information of their matches such as team statistics, and match results.


**Objective:**
The sole objective of this project is to perform data cleaning: handling missing values, removing duplicates, handling inconsistent data, and transforming the data into a suitable format for analysis, visualization and modeling tasks.


**Dataset Description:**
The FIFA dataset consists of 18979 rows and 77 columns, including:

- Player information (ID, Name, LongName, photoUrl, playerUrl, Nationality, Age)
- Performance attributes (OVA, POT, Club, Contract, Positions, Height, Weight, Preferred Foot)
- Skills and abilities (Attacking, Crossing, Finishing, Heading Accuracy, etc.)
- Goalkeeping attributes (GK Diving, GK Handling, GK Kicking, GK Positioning, GK Reflexes)
- Physical attributes (Acceleration, Sprint Speed, Agility, Reactions, Balance, Power)
- Mental attributes (Mentality, Aggression, Interceptions, Positioning, Vision, Penalties)
- Defensive attributes (Defending, Marking, Standing Tackle, Sliding Tackle)
- Total Stats, Base Stats, and other miscellaneous attributes (W/F, SM, A/W, D/W, IR, PAC, SHO, PAS, DRI, DEF, PHY, Hits)


**Goals of Data Cleaning Phase:**

- Handle missing values
- Remove duplicates and redundant data
- Correct errors and inconsistencies
- Transform data into a suitable format for analysis
- Ensure data quality and integrity

By achieving these goals, we will produce a refined and reliable dataset ready for analysis, visualization, and modeling tasks.

## **Import the necessay libraries**
"""

import pandas as pd
import numpy as np
import re # for regex expression
import datetime as dt

"""## **Import Dataset**"""

df = pd.read_csv("fifa21 raw data v2.csv")

# first 5 rows
df.head()

# last 5 rows
df.tail()

# Dimension of the dataset
df.shape

# Information of the data
df.info()

"""The dataset's information reveals a mix of data types, comprising both object and integer values, and also indicates the presence of null and non-null features, providing a comprehensive overview of the data's structure and content."""

# Summary Statistics of the dataset
df.describe().T

"""The summary statistics above displays the count, mean, standard deviation, minimum, percentile and maximum values of all numeric data."""

# Check the column names
df.columns

# Drop Unnecessary redundant columns
df.drop(columns = ["Name", "photoUrl", "playerUrl"], inplace = True)

"""We removed the columns because they lacked relevant information and/or are redundant in the dataset."""

# Renaming the columns to improve readability and understanding of the data
df = df.rename(columns= {"LongName":"Name","↓OVA":"Overall_Rating",
                "POT": "Potential_Rating", "W/F": "Weak_Foot",
               "SM": "Skill_Moves", "A/W":"Attack_Willingness", "FK Accuracy" : "Free_Kick_Accuracy",
                "GK Diving" :"Goal_Keeper_Diving",
               "PAC": "Passing", "DRI":"Dribbling", "DEF": "Defending",
               "PHY": "Physicality", "BOV": "Ball_Outreach_Vision"})

"""## **Handling Missing Values**"""

# Number of missing values
df.isnull().sum().to_dict()

# Alternatively, df.isnull().to_frame().transpose()

"""With the exception of "Loan Date End" and "Hits", which have 17,966 and 2,595 missing values respectively, all features have complete data. To address this, we can either drop these columns or replace the missing values with suitable alternatives such as mean, mode, median, or other relevant values. For the purpose of data cleaning, we will opt to replace the missing values to maintain data integrity and facilitate analysis.

### Handling Missing Data in the Loan Date End Feature
"""

# Count the missing and non missing values
df["Loan Date End"].isna().value_counts()

# Unique values
df["Loan Date End"].unique()

"""We are to conduct a cross-validation exercise to verify the missing values in the "Loan Date End" feature by cross-checking them against the "Contract" and "Joined" features, seeking any potential correlations or matches, and printing the results to ensure data accuracy and consistency."""

# filter out the nan rows in loan date end column
filtered_null_loan = df[df["Loan Date End"].isna()]

# Print
print(f"\n The null values:")
print(filtered_null_loan[["Loan Date End","Contract","Joined" ]].sample(10))

# crosscheck the contract and loan date end columns for correspondance
filtered_not_null =df[df["Loan Date End"].notna()]

# print result
print(f"\n The not-null values:""\n")
print(filtered_not_null[["Loan Date End", "Contract", "Joined"]].sample(20))

"""Upon observing that the 'Contract' feature dates align with the 'Loan Date End' feature, we can conclude that the missing 'Loan Date End' values can be reliably replaced with the corresponding 'Contract' values, ensuring data consistency and accuracy. However, since the dates are identical and the 'Contract' feature also indicates loan status, we opt to drop the redundant 'Loan Date End' feature, preserving data efficiency and clarity."""

# drop Loan Date End column
df = df.drop(columns=["Loan Date End"])

"""### Imputing Missing Values in the Hits Feature



"""

# Count the missing and non missing values
df["Hits"].isna().value_counts()

# Unique Values
df["Hits"].unique()

"""The null values in the "Hits" feature will be replaced with zero, signifying no tackles or contact, thereby acknowledging potential non-participation in plays or lack of recorded tackles, and providing a more comprehensive understanding of player performance by accounting for these instances."""

# Replace with Zero
df["Hits"] = df["Hits"].fillna(0)

# Checking if the changes had the desired impact
df["Hits"].isna().sum()

"""With the successful replacement of null values in the "Hits" and "Loan Date End" features, we have effectively addressed the issue of missing data, ensuring a more complete and accurate dataset.

## **Checking Duplicates**
"""

# Check for duplicates
df.duplicated().any()

"""Since there are no duplicates, we move on to the next cleaning phase.

## **Standardizing Data Format**

"Next, we will standardize the data by transforming columns into a consistent and uniform format, making it more efficient to work with and analyze.
These features include:

*  Height and Weight
*  Hits
*  Club
*  Value, Wage, Release Clause
*  IR
*  Name
* Contract

### A) Convert Height and Weight To Numerical data

#### Height Feature:
"""

# Info of the features
df[["Height", "Weight"]].info()

# Display unique values within feature
df["Height"].unique()

"""The "Height" feature, currently stored as an object data type, exhibits inconsistent formatting, with values expressed in both centimeters (cm) and feet & inches. To achieve numerical uniformity, we must first remove the unit labels (cm) and then convert the feet and inches values to centimeters, enabling a successful conversion to a numerical data type."""

# Replace cm with " "
df["Height"] =  df["Height"].str.replace("cm", "")

# function to convert height in feet and inches to cm
def convert_to_cm(x):
  """
  Converts a height measurement to centimeters.

  Parameters:
  x (str or float): The height measurement to convert.

  Returns:
  float: The height measurement in centimeters .
  """
  if '\'' in x:
        feet, inches = x.split('\'')
        inches = inches.replace('"', '')
        total_inches = int(feet) * 12 + int(inches)
        cm = total_inches * 2.54
        return cm
  else:
        return float(x)

# Apply the function to the Height column
df['Height'] = df['Height'].apply(convert_to_cm)

# Convert the Height column to integer
df['Height'] = df['Height'].astype(int)

# Verifying the effectiveness of the changes
df['Height'].unique()

"""#### Weight Feature:"""

df["Weight"].unique()

"""The "Weight" feature contains values expressed in both kilograms (kg) and pounds (lbs), necessitating a conversion to a standardized unit. Specifically, we need to convert the pounds values to kilograms, extract the numerical values by removing the unit labels, and finally convert the column to a numerical data type.



"""

# Function to convert Ibs to kg
def convert_to_kg(column, kg = 0.453592):
   """
   Converts a weight value from pounds (lbs) to kilograms (kg).

   Parameters:
   column (str or numeric): The weight value to convert. Can be a string containing "lbs" or a numeric value.
   kg (float, optional): The conversion factor from pounds to kilograms. Default is 0.453592.

   Returns:
   float: The converted weight value in kilograms.

   Notes:
   If the input is a string that doesn't contain "lbs", it is returned unchanged.
   """
   if isinstance(column, str):
        if "lbs" in column:
            con_kg = float(column.replace("lbs", "")) * kg
            return con_kg
        elif "kg" in column:
            return float(column.replace("kg", ""))
   return column

# Applying the function to the "Weight" column
df["Weight"] = df["Weight"].apply(convert_to_kg)

# Converting to int
df["Weight"] =  df["Weight"].astype(int)

# Verifying the effectiveness of the changes
df["Weight"].unique()

# Modify the columns name to show the unit of measurement at the header
df = df.rename(columns ={"Height": "Height(cm)",
                    "Weight": "Weight(kg)"})

"""#### Hits Feature:"""

df["Hits"].info()

df["Hits"].unique()

"""The "Hits" feature, currently represented as an object data type, requires standardization and cleaning. Some values in this column are expressed in thousands, denoted by the abbreviation "k", and also float values. To ensure consistency, we need to remove the "k" notation, multiply the values by 1000, and convert the column to an integer data type. This will enable us to uniformly represent the number of tackles made by a player in a season, allowing for accurate analysis and processing.




"""

def convert_to_thousand(x):
  """
    Converts a string value to a float,
    multiplying by 1000 if the value is in thousands (denoted by "K").

    Parameters:

    - x (string): The value to be converted.

    Returns:

    - thou_hits (float): The converted value.
  """
  if type(x) == str:  # Check if x is a string
        if "K" in x:
            thou_hits = float(x.replace("K"," ")) * 1000
            return thou_hits
  else:
    return float(x)

# Applying the function to the "Hits" column
df["Hits"] = df["Hits"].apply(convert_to_thousand)

# Convert data type to int
df["Hits"] = df["Hits"].astype(int)

# Verifying the effectiveness of the changes
df["Hits"].unique()

"""#### Club Feature:"""

# Unique values in Club features
df["Club"].unique()

# A random club feature infomation
df["Club"].sample(10)

"""It is apparent that the players are affiliated with various clubs, and the associated column requires cleaning. To achieve this, we need to perform the following tasks:

- Remove newline characters (\n) to consolidate the data into a single line
- Trim trailing spaces to ensure consistent formatting


"""

# Remove the newlines
df["Club"] = df["Club"].str.replace("\n", " ")

# Determining if the changes were successful
print(f'\nThe unique clubs are:\n')
df["Club"].unique()

# Replace digits attached to club names with empty string
df["Club"] = df["Club"].str.replace(r'\d+', '', regex=True)

# Replace dots attached to club names with empty string
df["Club"] = df["Club"].str.replace(r'. ', '', regex=True)

# Remove the leading and trailing characters (spaces, tabs, etc.)
df["Club"] = df["Club"].str.strip()

# Assessing the impact of the changes
df["Club"].sample(5)

"""#### Value, Wage and Release Clause Features:

"""

# Check datatype
data_type = df[["Value", "Wage","Release Clause"]].dtypes

# Print datatype
print(f"\nThe datatypes are:")

print(data_type)

# Assessing values within the features
random_rows = df[["Value", "Wage","Release Clause"]].sample(10)

# Print
print(f"\n{random_rows}")

"""These features contain monetary values, currently in object dtype, and require conversion to numerical dtype for analysis. To achieve this, we need to:

*  Remove the euro symbol (€) from the values
*  Remove the thousand separator ('k') and multiply the values by 1000
   to convert to the correct scale.


"""

# Remove the euro symbol (€)
df["Value"] = df["Value"].map(lambda x: x.replace("€", ""))

df["Wage"] = df["Wage"].map(lambda x: x.replace("€", ""))

df["Release Clause"] = df["Release Clause"].map(lambda x: x.replace("€", ""))

# Assessing the update
df[["Value", "Wage","Release Clause"]]

# Function to convert monetary values to numerical
def convert_to_numeric(value, t = 1000, m = 1000000, b = 1000000000):
  """
    Converts a string a numeric value, handling thousand (K), million (M), and billion (B) suffixes.

    Parameters:
    value (str): The value to convert.
    t (int, optional): The multiplier for thousand (default is 1000).
    m (int, optional): The multiplier for million (default is 1000000).
    b (int, optional): The multiplier for billion (default is 1000000000).

    Returns:
    float: The converted numeric value.

   Notes:
   If the input is a string, it may contain a suffix (K, M, or B) indicating the scale.
   If the input is already a numeric value, it is returned unchanged.
  """

  if type(value) == str:
     if "K" in value:
        return float(value.replace("K", " "))* t
     elif "M" in value:
        return float(value.replace("M", " "))* m
     elif "B" in value:
        return float(value.replace("B", " "))* b
     else:
        return float(value)
  return value



# columns to convert
columns_to_convert = ["Value", "Wage", "Release Clause"]

# Loop through the columns
for column in columns_to_convert:

# Apply the function to the columns
  df[column] = df[column].apply(convert_to_numeric)

# Verifying the effectiveness of the updates
df[["Value", "Wage", "Release Clause"]].dtypes

# Properly insert the euro symbol (€) into the column header
df = df.rename(columns={"Value": "Value(€)", "Wage": "Wage(€)", "Release Clause": "Release Clause(€)"})

# Assessing the impact of the changes
df[["Value(€)", "Wage(€)", "Release Clause(€)"]].sample(5)

"""#### IR  Feature:
This column actually represents player ratings or rankings, with the number of stars (★) indicating the level of performance.


"""

df["IR"].unique()

"""The column contains player ratings in the format of '★', and we need to remove the ★ symbol from the values, leaving only the numerical rating."""

# Remove ★
df["IR"] = df["IR"].str.replace("★", " ").astype(int)

# Display 10 random values
df["IR"].sample(10)

"""#### Name Feature:"""

# First 5 names
df["Name"].head()

# Capitalizes the first letter of each name
df["Name"] = df["Name"].str.title()

# Verying the update
df["Name"].head()

"""#### Contract Feature:"""

# Unique values in Contract feature
df["Contract"].unique()

"""The column, intended to display only the end years of contracts, contains additional information, with some entries denoted as "on loan" for players on loan and "free" for players on a free transfer, as well as different date formats, requiring data cleaning and preprocessing to extract the relevant contract years.

"""

# Retrive rows in the contract column that contains "On Loan"
loan_rows = df[df["Contract"].str.contains("On Loan")]
loan_rows

"""1013 players are on loan"""

#Retrive rows in the contract column that contains "Free"
free_rows = df[df["Contract"].str.contains("Free")]
free_rows

"""237 players are on free transfer"""

df[["Contract", "Joined"]].sample(5)

"""We have to:

* Create new Status columns which returns True for players "On Loan" and vice-versa
* We will do same for players on "Free" transfer.
* Remove "On Loan" and "Free" information from the Contract column.
* Modify the Contract column into Contarct End Date.
"""

def player_status(x):
  """
    Determine if a player was on loan transfer.

    Parameters:
    x (str): The contract information.

    Returns:
    bool: True if the player was signed on loan, False otherwise.
"""
  if "On Loan" in x:
      return True
  else:
      return False

# Apply the function to the Contract column to create the Player_on_Loan column
df["Player_on_Loan"] = df["Contract"].apply(player_status)

df[["Contract", "Player_on_Loan"]].sample(15)

def free_transfer(x):
  """
    Determine if a player was signed on a free transfer.

    Parameters:
    x (str): The contract information.

    Returns:
    bool: True if the player was signed on a free transfer, False otherwise.
"""
  if "Free" in x:
        return True
  else:
        return False

# Apply the function to the Contract column to create the Player_on_Loan column
df["Free_transfer"] = df["Contract"].apply(free_transfer)

df[["Contract", "Free_transfer"]].sample(10)

# Remove On Loan and free string from contract column
df["Contract"]  = df["Contract"].str.replace("On Loan","")

df["Contract"]  = df["Contract"].str.replace("Free","")

# Verifying the update
df["Contract"].unique()

"""The Contract feature was meant to show contract duration (end year), but has inconsistent formatting. However, some rows incorrectly include the day and month."""

# Function to clean the Contract column
def clean_contract(date_str):
   """
   Cleans a date string by removing month, day, and unnecessary characters.

   Parameters:
   date_str (str): The input date string to be cleaned.

   Returns:
   str: The cleaned date string with only the year remaining
   """
    # Remove month and date
   date_str = re.sub(r'[A-Za-z]+\s+\d{1,2},\s+', '', date_str)
    # Keep only the year before the ~ symbol
   date_str = re.sub(r'\s*~\s*\d{4}', '', date_str)
   return date_str.strip()

# Apply the function to the date column
df["Contract_End_Date"] = df["Contract"].apply(clean_contract)

df['Contract_End_Date'].sample(10)

# Drop Contract column
df = df.drop(columns=["Contract"])

# first 10 rows
df.head(10)

# first 10 last rows
df.tail(10)